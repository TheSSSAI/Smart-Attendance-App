import * as functions from "firebase-functions";
import { TenantRegistrationDto } from "@/application/dtos/TenantRegistrationDto";
import { IAuditLogService } from "@/domain/interfaces/IAuditLogService";
import { IAuthService } from "@/domain/interfaces/IAuthService";
import { ITenantRepository } from "@/domain/interfaces/ITenantRepository";
import { ITenantService } from "@/domain/interfaces/ITenantService";
import { IUserRepository } from "@/domain/interfaces/IUserRepository";
import { HttpsError } from "firebase-functions/v2/https";
import { AuditLog } from "@/domain/entities/AuditLog";
import { Tenant } from "@/domain/entities/Tenant";
import { User } from "@/domain/entities/User";

export class TenantService implements ITenantService {
  constructor(
    private readonly tenantRepository: ITenantRepository,
    private readonly userRepository: IUserRepository,
    private readonly authService: IAuthService,
    private readonly auditLogService: IAuditLogService
  ) {}

  /**
   * Registers a new organization tenant and its initial administrator.
   * This is a complex, multi-step, atomic operation.
   * 1. Validates organization name uniqueness.
   * 2. Creates Firebase Auth user.
   * 3. Creates Tenant and User documents in Firestore within a transaction.
   * 4. Sets custom claims on the Auth user for RBAC.
   * 5. Implements compensating actions to roll back changes on failure.
   * @param data - The DTO containing registration information.
   * @returns The newly created admin's user ID.
   * @throws {HttpsError} 'already-exists' if the organization name is taken.
   * @throws {HttpsError} 'internal' for any other failures during the process.
   */
  async registerNewTenant(data: TenantRegistrationDto): Promise<{ userId: string; tenantId: string }> {
    functions.logger.info("Starting new tenant registration for organization:", data.orgName);

    // Step 1: Validate organization name uniqueness (case-insensitive)
    const isNameTaken = await this.tenantRepository.isNameTaken(data.orgName);
    if (isNameTaken) {
      functions.logger.warn("Attempted to register with duplicate organization name:", data.orgName);
      throw new HttpsError("already-exists", "This organization name is already taken. Please choose another.");
    }

    // Step 2: Create Firebase Auth user
    let authUserUid: string | null = null;
    try {
      const { uid } = await this.authService.createUser({
        email: data.email,
        password: data.password,
        displayName: data.adminName,
      });
      authUserUid = uid;
      functions.logger.info(`Successfully created Auth user with UID: ${uid} for org: ${data.orgName}`);
    } catch (error: any) {
      functions.logger.error("Failed to create Firebase Auth user during registration.", { error, email: data.email });
      throw new HttpsError("internal", "Failed to create user account. Please try again.");
    }

    // Step 3 & 4: Create Tenant and User documents in Firestore atomically and set custom claims
    let tenantId: string;
    try {
      const tenant = new Tenant("", data.orgName, "free-tier"); // ID will be generated by repository
      const user = new User(authUserUid, "", data.adminName, data.email, "Admin", "active"); // TenantID will be set by repository

      // This transaction ensures the tenant and user are created together or not at all.
      tenantId = await this.tenantRepository.createWithAdmin(tenant, user);
      functions.logger.info(`Atomically created Tenant (${tenantId}) and Admin User (${authUserUid}) documents.`);

      // Step 5: Set custom claims
      await this.authService.setCustomClaims(authUserUid, { tenantId, role: "Admin" });
      functions.logger.info(`Successfully set custom claims for Admin ${authUserUid}.`);

      // Step 6: Create audit log entry
      const auditLog = new AuditLog(
        "", // ID will be generated
        "SYSTEM",
        "tenant.create",
        tenantId,
        "Tenant",
        `New tenant '${data.orgName}' created with initial Admin '${data.email}'.`,
        { orgName: data.orgName, adminEmail: data.email }
      );
      await this.auditLogService.log(tenantId, auditLog);
    } catch (error: any) {
      functions.logger.error("Critical failure during tenant/user document creation or claim setting. Rolling back.", {
        authUserUid,
        error,
      });
      // Step 7: Compensating action - delete the Auth user if anything fails after its creation.
      if (authUserUid) {
        await this.authService.deleteUser(authUserUid);
        functions.logger.warn(`Rollback complete: Deleted orphaned Auth user ${authUserUid}.`);
      }
      throw new HttpsError("internal", "An error occurred during organization setup. Please try again.");
    }

    return { userId: authUserUid, tenantId };
  }

  /**
   * Initiates the 30-day grace period for tenant deletion.
   * @param tenantId The ID of the tenant to mark for deletion.
   * @param adminId The ID of the Admin requesting the deletion.
   * @throws {HttpsError} 'not-found' if the tenant does not exist.
   * @throws {HttpsError} 'failed-precondition' if the tenant is not in an 'active' state.
   */
  async initiateTenantDeletion(tenantId: string, adminId: string): Promise<void> {
    functions.logger.info(`Initiating deletion for tenant ${tenantId}, requested by admin ${adminId}.`);

    const tenant = await this.tenantRepository.findById(tenantId);
    if (!tenant) {
      throw new HttpsError("not-found", `Tenant with ID ${tenantId} not found.`);
    }

    if (tenant.status !== "active") {
      throw new HttpsError("failed-precondition", `Tenant is not in an active state and cannot be deleted.`);
    }

    const deletionScheduledAt = new Date();
    deletionScheduledAt.setDate(deletionScheduledAt.getDate() + 30);

    await this.tenantRepository.update(tenantId, {
      status: "pending_deletion",
      deletionScheduledAt,
    });
    functions.logger.info(`Tenant ${tenantId} successfully marked for deletion on ${deletionScheduledAt.toISOString()}.`);

    const auditLog = new AuditLog(
      "",
      adminId,
      "tenant.deletion.request",
      tenantId,
      "Tenant",
      `Admin requested permanent deletion of the tenant. Grace period ends ${deletionScheduledAt.toISOString()}.`
    );
    await this.auditLogService.log(tenantId, auditLog);
  }

  async cancelTenantDeletion(tenantId: string, adminId: string): Promise<void> {
    functions.logger.info(`Cancelling deletion for tenant ${tenantId}, requested by admin ${adminId}.`);

    const tenant = await this.tenantRepository.findById(tenantId);
    if (!tenant) {
      throw new HttpsError("not-found", `Tenant with ID ${tenantId} not found.`);
    }

    if (tenant.status !== "pending_deletion") {
      throw new HttpsError("failed-precondition", `Tenant is not pending deletion.`);
    }

    await this.tenantRepository.update(tenantId, {
      status: "active",
      deletionScheduledAt: null,
    });
    functions.logger.info(`Deletion for tenant ${tenantId} has been cancelled.`);

    const auditLog = new AuditLog(
      "",
      adminId,
      "tenant.deletion.cancel",
      tenantId,
      "Tenant",
      "Admin cancelled the scheduled permanent deletion of the tenant."
    );
    await this.auditLogService.log(tenantId, auditLog);
  }
}